# 宠物状态系统

## 主要的交互逻辑

+ 宠物有多种属性, 需要随着时间更新, 触发一定事件的时候, 使用之前提过的对话接口提醒宠物
+ 宠物可以使用物品, 使用物品时候影响状态, 同时提醒宠物
+ 宠物可以升级进行数据的提升以及解锁自己配置的物品
+ 目前实现的游戏使用的是暂时使用一个游戏的提示词, 以及为AI提供了几个他可以控制的游戏属性

## 数据结构

### 宠物类

```c

    private:
        std::mutex mutex_;
        state_t state_[E_PET_STATE_NUMBER];     // 当前状态
        int game_state_[E_PET_GAME_STATE_NUMBER]; // 游戏状态
        
        std::vector<BaseThing *> things_; // 物品列表
        std::vector<FocueInfo> focus_list_; // 关注列表
        electronic_pet_action_e action_; // 当前行动
        electronic_pet_action_e action_last_; // 上次行动
    
        int current_game_ = 0;
        int is_game_ = 0;
        int level_ = 0; // 等级
        int experience_ = 0; // 经验值
        
    
        PMQTT_Clinet *client_; // MQTT客户端
        bool use_web_server_ = false;
        std::string boardID;
    
    public:
        EventGroupHandle_t message_send_event_ = nullptr;
        std::vector<GameInfo> games_;
        static int state_time_change_[E_PET_ACTION_NUMBER][E_PET_STATE_NUMBER]; // 不同状态下边宠物的状态变化
        static std::string action_name_[E_PET_ACTION_NUMBER]; // 不同状态下边宠物的状态变化
        ElectronicPetTimer *timer;
        static ElectronicPet* MyPet;
        ElectronicPet();
        ~ElectronicPet();
    
        PMQTT_Clinet *GetClient() { return client_; }
    
    
        int GetAction() const { return action_; } // 获取当前的行为
        void SetAction(int action); // 设置当前的行为
        int GetState(int state) const { return state_[state].value; } // 获取当前的某一个状态
        void SetState(int state, int value); // 设置当前的某一个状态
        void SetStateName(int state, const char* name) { strcpy(state_[state].name, name); } // 设置状态的名字
        char *GetStateName(int state) { return state_[state].name; } // 获取某个状态的名字
        char *GetActionName() { return (char *)action_name_[action_].c_str(); } // 获取当前行为的名字
        // 对当前的状态实现加减
        void change_statue(int *change_state);


        // 从SD卡读取csv文件
        void ReadCsv();  // 从SD卡读取csv文件
        // 读取csv的食物
        void ReadCsvFood(int *i);
        // 创建一个物品
        bool CreatOneThing(char *name, char *description, int vigor_, int satiety_, int happiness_, int money_, int iq_, int level, int *i);
        // 读取游戏的配置文件
        void ReadCsvGames();
        // 获取有几个物品
        int GetThingsNum() { return things_.size();}
        // 获取某个物品
        BaseThing *GetThing(int i) { if (i < 0 || i >= things_.size()) return nullptr;return things_[i]; }
        // 获取当前的游戏索引
        int GetCurrentGame() { return current_game_; }
        // 设置当前的游戏索引
        void SetCurrentGame(int game) { current_game_ = game; }
        // 返回之前的状态, 主要用于游戏返回的时候
        void ReturnLastAction();


        // 设置游戏状态(用于处理游戏时候的特殊判断
        inline int isGame() const { return action_ == E_PET_ACTION_PLAY; }
        // 设置游戏的马哥粗略的
        void setGameState(int state, int value) { game_state_[state] = value; }
        int getGameState(int state) const { return game_state_[state]; }
        // 处理一下状态变换以后的回复
        void StateEventDeal();


        // 经验以及升级
        int getLevel() { return level_; }
        int getExperience() { return experience_; }
        // 判断是不是可以升级(升级部分是不完善的)
        inline bool isUpGraded(){return experience_ >= level_ * level_;}
        std::string ReadUpgradeTaskCsv(int level);
        std::string GetUpdateTask(void);
        bool Upgrade(void);
        
        // 在其他文件用于获取宠物句柄
        static ElectronicPet* GetInstance();
    
    
        // 获取板子的ID用于和微信小程序配合
        std::string GetBoardID(void);
        // 读取各种消息
        void ReadWebThings(void);
        void ReadWebFood(int *thing_num);
        void ReadWebGames(void);
        void ReadWebFocus(void);
        std::string GetFocusListJson(void);
        std::vector<FocueInfo> GetFocusList(void){return focus_list_;};
        // 更新当前的状态
        void UploadState(void);
};
```

### 各项数值

+ 宠物的各项数值

```c
typedef enum{
    E_PET_STATE_VIGIR = 0, // 精力
    E_PET_STATE_SATITY, // 饱食度
    E_PET_STATE_HAPPINESS, // 快乐度
    // E_PET_STATE_GOOD_LINE 之前的数值用于判断状态好坏
    E_PET_STATE_IQ, // 智商
    // E_PET_DIVIDING_LINE 之前的数字有上限100
    E_PET_STATE_MONEY, // 金钱
    E_PET_STATE_NUMBER // 状态数量
}electronic_pet_state_e;
```

在处理这部分数据的时候, 前面的几项使用的是百分之, 所以是有上限的, 后面的数据是没有上限的, 住部分之后在显示的时候需要区分一下

同时使用三个数值综合判断宠物的当前是不是感觉比较好, 比较好的话可以增加经验值

```c
#define E_PET_STATE_DIVIDING_LINE 4 // 分割线
#define E_PET_STATE_GOOD_LINE 3 // 分割线
```

+ 宠物的各种状态

```c
typedef enum{
    E_PET_ACTION_IDLE = 0, // 空闲
    E_PET_ACTION_PLAY, // 玩耍
    E_PET_ACTION_SLEEP, // 睡觉
    E_PET_ACTION_WALK, // 散步
    E_PET_ACTION_BATH, // 洗澡
    E_PET_ACTION_WORK, // 工作
    E_PET_ACTION_STUDY, // 学习
    E_PET_ACTION_PLAY_MUSIC, // 听音乐
    E_PET_ACTION_NUMBER // 状态数量
}electronic_pet_action_e;
```

> 这部分的数据主要是对应于之后我想实现的功能, 处于不同状态的时候宠物的数据会以不同的形式进行更新

+ 打游戏的时候使用的几项数据

```c
typedef enum{
    E_PET_GAME_STATE_HP = 0, // 血量
    E_PET_GAME_STATE_SCORE, // 分数
    E_PET_GAME_STATE_ENERGY, // 能量
    E_PET_FAME_STATE_FAME, // 名声
    E_PET_GAME_STATE_NUMBER // 状态数量
}electronic_pet_game_state_e;
```

> 提升游戏沉浸感, 是AI可以直接控制的数据

## 数据的更新

### 状态的更新

由于不同的行为下面的宠物状态的更新是不同的, 所以这里需要记录一下不同的情况里面是如何更新的, 我使用的是一个数组, 在数据更新以后需要检查一下实际当前的状态 , 是不是达到一定的阈值, 如果是的话, 宠物需要和用户发起互动(比如我饿了)

```c
static int state_time_change_[E_PET_ACTION_NUMBER][E_PET_STATE_NUMBER]; // 不同状态下边宠物的状态变化
```

```c
// 精力, 饱食度, 快乐度
int ElectronicPet::state_time_change_[E_PET_ACTION_NUMBER][E_PET_STATE_NUMBER] = {
    /* E_PET_ACTION_IDLE 空闲*/      {-1, -1, -1, 0, 0},
    /* E_PET_ACTION_PLAY 玩耍*/       {-3, -3, 5, 0, 0},
    /* E_PET_ACTION_SLEEP 睡觉*/      {2, -1, 0, 0, 0},
    /* E_PET_ACTION_WALK 走路*/       {-2, -2, 1, 0, 0},
    /* E_PET_ACTION_BATH 洗澡*/       {-1, -1, 1, 0, 0},
    /* E_PET_ACTION_WORK 工作*/       {-4, -2, -4, 0, 1},
    /* E_PET_ACTION_STUDY 学习*/      {-4, -2, -3, 1, 0},
    /* E_PET_ACTION_PLAY_MUSIC 听歌*/ {-1, -1, 2, 0, 0}
};
```

> 每一行对应一个行为状态, 每一列对应的是一个状态, 在单次更新的时候更新的数值的大小

这部分数据需要定期进行更变, 所以要初始化一个时钟, 这里使用的是时钟系统里面的时钟回调函数(时钟系统后面讲), 在里面会执行函数

```c
void ElectronicPetTimer::OnClockTimer() {    
	// 加锁避免互斥
    std::lock_guard<std::mutex> lock(mutex_);
    timer_event_process(); // 时钟事件的处理函数, 暂时不用管
    clock_ticks_++; // 更新事件
    // 获取一下宠物
    ElectronicPet* pet = ElectronicPet::GetInstance();
    if(pet == nullptr){
        return;
    }
    // 初级的处理部分
    if(clock_ticks_ % (1000 / CONFIG_FREQUENCE_OF_PET) == 0){
        ESP_LOGI(TAG, "Clock ticks: %d", clock_ticks_);
        // 更新一下状态
        int state[E_PET_STATE_NUMBER]; // 记录更新的数值大小
        for(int i = 0; i < E_PET_STATE_NUMBER; i++){
            state[i] = ElectronicPet::state_time_change_[pet->GetAction()][i];
        }
        state[E_PET_STATE_MONEY] *= (state[E_PET_STATE_IQ] / 20); // 智商越高，钱越多
        pet->change_statue(ElectronicPet::state_time_change_[pet->GetAction()]);
        

        if(clock_ticks_ % 1000 == 0){
            pet->UploadState(); // 同步到服务器
        }

        if(pet->isGame() == false){
            pet->StateEventDeal(); // 状态在一定阈值的时候需要主动发起聊天
        }
    }
}
```

## 升级

目前的升级系统还是不完善的, 但是我还没有特别好的想法, 之后有的话会进行迭代

在`StateEventDeal`函数里面会判断当前的状态, 如果前面几项用于判断宠物的状态的属性达标, 进行经验的增长

```c
for(int i = 0; i < E_PET_STATE_GOOD_LINE; i++){
    if(state_[i].value > 75){
        good_state++;
    }
}
if(good_state == E_PET_STATE_GOOD_LINE){
    // 触发好心情事件
    experience_ += 1;
}
```

经验达标以后即可进行升级, 在进行升级的时候, 首先使用宠物随机获取一个升级任务, 一般是一个脑筋急转弯之类的(可以在SD卡模式的时候自己配置)

完成以后即可进行实际的升级, 在升级以后可以解锁配置物品里面的当前等级的物品, 同时进行状态值的提升]

## 物品

最基础的物品需要实现的有使用物品以后会对宠物状态的影响, 以及在使用物品以后通知宠物的描述

```c
typedef enum{
    E_THING_TYPE_FOOD = 0,
    E_THING_TYPE_TOY,
    E_THING_TYPE_CLOTHES,
}thing_type_e;

class BaseThing{
public:
    BaseThing(const char * name, lv_image_dsc_t thing_pic, const char *thing_description, thing_type_e thing_type, int num, int *state, int level)
        : thing_pic(thing_pic), thing_type(thing_type), num_(num){
            name_ = name; // 名字
            thing_description_ = thing_description; // 描述
            vigor_ = state[E_PET_STATE_VIGIR]; // 金钱
            satiety_ = state[E_PET_STATE_SATITY]; // 精神状态
            happiness_ = state[E_PET_STATE_HAPPINESS]; // 快乐度
            money_ = state[E_PET_STATE_MONEY]; // 金钱
            iq_ = state[E_PET_STATE_IQ]; // 智商
            level_ = level;
        };

    virtual ~BaseThing() = default;

    virtual void Use(){}; // 使用物品
    int GetNum() const { return num_; }
    void SetNum(int num);
    int GetVigor() const { return vigor_; }
    void SetVigor(int vigor) { vigor_ = vigor; }
    int GetSatiety() const { return satiety_; }
    void SetSatiety(int satiety) { satiety_ = satiety; }
    int GetHappiness() const { return happiness_; }
    void SetHappiness(int happiness) { happiness_ = happiness; }
    int GetMoney() const { return money_; }
    void SetMoney(int money) { money_ = money; }
    int GetIq() const { return iq_; }
    void SetIq(int iq) { iq_ = iq; }
    const char *GetName() const { return name_.c_str(); }
    const char *GetDescription() const { return thing_description_.c_str(); }
    int GetLevel(){return level_;};
    
protected:
    std::mutex mutex_;
    std::string name_;
    lv_image_dsc_t thing_pic;
    std::string thing_description_; // 使用之后发送给小智
    thing_type_e thing_type; // 种类(暂时未使用)
    int num_;
    int money_; // 金钱
    int vigor_; // 精神状态
    int satiety_; // 饱食度
    int happiness_; // 快乐度
    int iq_; // 智商
    int level_;
};
```

当前只有食物一种物品

```c
class Food: public BaseThing {
private:
public:
    Food(const char * name, lv_image_dsc_t thing_pic, const char *thing_description, int *state,int num = 1, int level = 1)
        : BaseThing(name, thing_pic, thing_description, E_THING_TYPE_FOOD, num, state, level) {}
    void Use() override;
};
```









