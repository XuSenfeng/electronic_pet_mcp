# 小智二次开发

## 小智源码

### 状态机

```c
enum DeviceState {
    kDeviceStateUnknown, // 未知状态
    kDeviceStateStarting, // 启动状态
    kDeviceStateWifiConfiguring, // 配置网络状态
    kDeviceStateIdle, // 空闲状态
    kDeviceStateConnecting, // 连接状态
    kDeviceStateListening, // 聆听状态
    kDeviceStateSpeaking, // 说话状态
    kDeviceStateUpgrading, // 升级状态
    kDeviceStateActivating, // 激活状态
    kDeviceStateFatalError // 错误状态
};
```

![image](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509060051851.jpeg)

### 利用AI对话

默认的小智在唤醒的时候会发送一个提示词给服务器, 用于发起一次对话, 可以包唤醒词改为实际的消息进行发送, 从而实现文本交互的效果, 但是原有的接口直接使用会出现状态机处理比较麻烦, 发送的文本导致报错等问题, 所以我把这个部分单独度封装了一下

```c
void Application::SendMessage(std::string& message) {
    ESP_LOGI(TAG, "Send message: %s", message.c_str());
    // 处理一下非法的字符
    message.erase(std::remove(message.begin(), message.end(), '\n'), message.end());
    message.erase(std::remove(message.begin(), message.end(), '\"'), message.end());
    message.erase(std::remove(message.begin(), message.end(), '\r'), message.end());
    // 处理一下状态机
    if (device_state_ == kDeviceStateIdle) {
        ToggleChatState(true);
        Schedule([this, message]() {
            if (protocol_) {
                protocol_->SendWakeWordDetected(message); 
            }
        }); 
    } else if (device_state_ == kDeviceStateSpeaking) {
        Schedule([this, message]() {
            AbortSpeaking(kAbortReasonNone);
            SetListeningMode(kListeningModeManualStop);
            if (protocol_) {
                protocol_->SendWakeWordDetected(message); 
            }
        });
    } else if (device_state_ == kDeviceStateListening) {   
        Schedule([this, message]() {
            if (protocol_) {
                protocol_->SendWakeWordDetected(message); 
            }
        });
    }

}
```

### 处理MCP

小智可以使用AI对话的时候进行工具调用, 我这里使用的MCP协议

相比于之前的iot协议, MCP有一个好处, 他可以返回实际的处理结果, 所以比之前的iot协议处理的稳定性更好

这里放一个原有的示例

![image-20250905213525953](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509052135017.png)

```c
enum PropertyType {
    kPropertyTypeBoolean,
    kPropertyTypeInteger,
    kPropertyTypeString
};
```

> 输入的参数可以有这三种

```c
using ReturnValue = std::variant<bool, int, std::string>;
```

> 返回的参数也需要是这三种

### 自动息屏

分析一下需要处理的情况

+ 空闲状态的时候一定时间以后进行息屏
+ 息屏的时候需要记录息屏之前的状态=>用于亮屏的时候返回
+ 按键按下的时候第一次进行亮屏, 第二次才是对话
+ 说啥的时候以及功能界面的时候不可以进行息屏

实际实现的时候, 需要实现一个周期为1s的闹钟, 同时根据状态机的情况进行处理不同页面的时钟计时策略, 在设置屏幕亮度的时候需要处理事用户主动的处理还是自动息屏的处理

### 显示的接口

![image-20250906140554163](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509061406512.png)

### OTA系统

![image-20250906141001397](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509061410436.png)

ota原本的含义是升级系统, 但是实际官方的这个网址实现的还有一系列的信息获取, 所以**直接把这个删除**的形式是不可取的, 但是可以使用修改代码的方式实现获取消息的同时不升级

![image-20250906141249446](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509061412562.png)

这个括号里面的代码是实际的升级部分, 可以直接把这部分的代码删除即可

> 为了使用更多的flash, 我把这部分功能重写了, 后面在单独的文件里面讲解

### Setting长期数据保存

esp32里面有一个nvs分区, 实际可以理解为一个字典, 里面记录的数据在离线的时候是不会丢失的, 小智对他进行了封装, 使用起来更加的方便

```c
Settings settings("wifi", false);
std::string url = settings.GetString("ota_url");
```

这里获取的数据可以理解为查询下面的数据结构

```json
{
    ...,
    "wifi": {
    	"ota_url": "实际的记录的ota网址
	},
	...
}
```

可以使用的接口如下

![image-20250906184913584](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509061849636.png)

## idf使用

### 配置文件

在使用idf的设置界面进行选择配配置的时候添加自定义的选项

[构建系统（CMake 版） - ESP32 - — ESP-IDF 编程指南 v4.2.1 文档](https://docs.espressif.com/projects/esp-idf/zh_CN/v4.2.1/esp32/api-guides/build-system.html#add-conditional-config)

```
menu "XvSenfeng Electronic Pet"
    config FREQUENCE_OF_PET
        int "宠物交互的频率,数字越大越频繁"
        default 5
    config PET_GAME_TEXT_LENG
        int "宠物游戏文本长度,数字越大越长"
        default 300

    config PET_MQTT_SERVER
        string "宠物MQTT服务器地址"
        default "mqtt.tenclass.net"
        help
            该服务器用于连接宠物设备的 MQTT 服务

    config SERVER_BASE_SERVER_URL
        string "宠物服务器地址"
        default "https://www.xvsenfeng.top"
        help
            该服务器用于连接宠物设备的 HTTP 服务
        
endmenu
```

这里面的配置可以在CMakeList.txt里面直接使用用于文件的配置, 也可以用于在代码里面使用条件编译

### 自定义库文件

idf一个比较好用的点是他提供了丰富的组件, 可以直接使用组件库进行添加[ESP Component Registry](https://components.espressif.com/)

这部分的配置放在idf_component.yml文件里面, 可以在这个文件里面直接添加组件, 也可以idf的终端里面直接使用![image-20250906112128343](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509061121407.png)这里获取到的命令

直接使用的时候会出现一个问题, 默认idf在编译的时候会检查重新下载库文件, 所以如果发现一个库文件的使用不符合预期, 需要进行自定义的时候, 你的修改会被覆盖

这时候可以先下载一个原版的库文件, 之后移出来使用path关键字指定你自己定制的库文件

![image-20250906112411910](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509061124978.png)

> 这里我修改了原版的表情图片, 为了避免自己被覆盖, 所以使用这个方法

