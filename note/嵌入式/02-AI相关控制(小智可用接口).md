# 小智二次开发

## 小智源码

### 状态机

```c
enum DeviceState {
    kDeviceStateUnknown, // 未知状态
    kDeviceStateStarting, // 启动状态
    kDeviceStateWifiConfiguring, // 配置网络状态
    kDeviceStateIdle, // 空闲状态
    kDeviceStateConnecting, // 连接状态
    kDeviceStateListening, // 聆听状态
    kDeviceStateSpeaking, // 说话状态
    kDeviceStateUpgrading, // 升级状态
    kDeviceStateActivating, // 激活状态
    kDeviceStateFatalError // 错误状态
};
```

![image](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509060051851.jpeg)

### 利用AI对话

默认的小智在唤醒的时候会发送一个提示词给服务器, 用于发起一次对话, 可以包唤醒词改为实际的消息进行发送, 从而实现文本交互的效果, 但是原有的接口直接使用会出现状态机处理比较麻烦, 发送的文本导致报错等问题, 所以我把这个部分单独度封装了一下

```c
void Application::SendMessage(std::string& message) {
    ESP_LOGI(TAG, "Send message: %s", message.c_str());
    // 处理一下非法的字符
    message.erase(std::remove(message.begin(), message.end(), '\n'), message.end());
    message.erase(std::remove(message.begin(), message.end(), '\"'), message.end());
    message.erase(std::remove(message.begin(), message.end(), '\r'), message.end());
    // 处理一下状态机
    if (device_state_ == kDeviceStateIdle) {
        ToggleChatState(true);
        Schedule([this, message]() {
            if (protocol_) {
                protocol_->SendWakeWordDetected(message); 
            }
        }); 
    } else if (device_state_ == kDeviceStateSpeaking) {
        Schedule([this, message]() {
            AbortSpeaking(kAbortReasonNone);
            SetListeningMode(kListeningModeManualStop);
            if (protocol_) {
                protocol_->SendWakeWordDetected(message); 
            }
        });
    } else if (device_state_ == kDeviceStateListening) {   
        Schedule([this, message]() {
            if (protocol_) {
                protocol_->SendWakeWordDetected(message); 
            }
        });
    }

}
```

### 处理MCP

小智可以使用AI对话的时候进行工具调用, 我这里使用的MCP协议

相比于之前的iot协议, MCP有一个好处, 他可以返回实际的处理结果, 所以比之前的iot协议处理的稳定性更好

这里放一个原有的示例

![image-20250905213525953](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509052135017.png)

```c
enum PropertyType {
    kPropertyTypeBoolean,
    kPropertyTypeInteger,
    kPropertyTypeString
};


// Required field constructor
Property(const std::string& name, PropertyType type)
    : name_(name), type_(type), has_default_value_(false) {}

// Optional field constructor with default value
template<typename T>
    Property(const std::string& name, PropertyType type, const T& default_value)
    : name_(name), type_(type), has_default_value_(true) {
        value_ = default_value;
    }

Property(const std::string& name, PropertyType type, int min_value, int max_value)
    : name_(name), type_(type), has_default_value_(false), min_value_(min_value), max_value_(max_value) {
        if (type != kPropertyTypeInteger) {
            throw std::invalid_argument("Range limits only apply to integer properties");
        }
    }

Property(const std::string& name, PropertyType type, int default_value, int min_value, int max_value)
    : name_(name), type_(type), has_default_value_(true), min_value_(min_value), max_value_(max_value) {
        if (type != kPropertyTypeInteger) {
            throw std::invalid_argument("Range limits only apply to integer properties");
        }
        if (default_value < min_value || default_value > max_value) {
            throw std::invalid_argument("Default value must be within the specified range");
        }
        value_ = default_value;
}
```

> 输入的参数可以有这三种

```c
using ReturnValue = std::variant<bool, int, std::string>;
```

> 返回的参数也需要是这三种

### 显示的接口

```c
auto display = Board::GetInstance().GetDisplay();
```

![image-20250906140554163](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509061406512.png)

### OTA系统

![image-20250910194710866](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509101947921.png)

ota原本的含义是升级系统, 但是实际官方的这个网址实现的还有一系列的信息获取, 所以**直接把这个删除**的形式是不可取的, 但是可以使用修改代码的方式实现获取消息的同时不升级

![image-20250906141249446](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509061412562.png)

这个括号里面的代码是实际的升级部分, 可以直接把这部分的代码删除即可

> 为了使用更多的flash, 我把这部分功能重写了, 后面在单独的文件里面讲解

### Setting长期数据保存

esp32里面有一个nvs分区, 实际可以理解为一个字典, 里面记录的数据在离线的时候是不会丢失的, 小智对他进行了封装, 使用起来更加的方便

```c
Settings settings("wifi", false);
std::string url = settings.GetString("ota_url");
```

这里获取的数据可以理解为查询下面的数据结构

```json
{
    ...,
    "wifi": {
    	"ota_url": "实际的记录的ota网址
	},
	...
}
```

可以使用的接口如下

![image-20250906184913584](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509061849636.png)

### 网络接口

#### http

```c
class Http {
public:
    virtual ~Http() = default;

    // Set timeout
    virtual void SetTimeout(int timeout_ms) = 0;

    // 设置 HTTP 请求头
    virtual void SetHeader(const std::string& key, const std::string& value) = 0;

    // 设置 HTTP Content
    virtual void SetContent(std::string&& content) = 0;

    // 打开 HTTP 连接并发送请求
    virtual bool Open(const std::string& method, const std::string& url) = 0;

    // 关闭 HTTP 连接
    virtual void Close() = 0;

    // 读取 HTTP 响应数据
    virtual int Read(char* buffer, size_t buffer_size) = 0;

    // 写入 HTTP 请求数据
    virtual int Write(const char* buffer, size_t buffer_size) = 0;

    // 获取 HTTP 响应状态码
    virtual int GetStatusCode() = 0;

    // 获取指定 key 的 HTTP 响应头
    virtual std::string GetResponseHeader(const std::string& key) const = 0;

    // 获取 HTTP 响应体长度
    virtual size_t GetBodyLength() = 0;

    // 获取 HTTP 响应体
    virtual std::string ReadAll() = 0;
};
```

```c
auto http = std::unique_ptr<Http>(Board::GetInstance().CreateHttp());
if (!http->Open("GET", url)) {
    ESP_LOGE(TAG, "无法打开HTTP连接");
    return false;
}
std::string data = http->ReadAll();
http->Close();
```

#### mqtt

```c
class Mqtt {
public:
    virtual ~Mqtt() {}

    void SetKeepAlive(int keep_alive_seconds) { keep_alive_seconds_ = keep_alive_seconds; }
    virtual bool Connect(const std::string broker_address, int broker_port, const std::string client_id, const std::string username, const std::string password) = 0;
    virtual void Disconnect() = 0;
    virtual bool Publish(const std::string topic, const std::string payload, int qos = 0) = 0;
    virtual bool Subscribe(const std::string topic, int qos = 0) = 0;
    virtual bool Unsubscribe(const std::string topic) = 0;
    virtual bool IsConnected() = 0;

    virtual void OnConnected(std::function<void()> callback) { on_connected_callback_ = callback; }
    virtual void OnDisconnected(std::function<void()> callback) { on_disconnected_callback_ = callback; }
    virtual void OnMessage(std::function<void(const std::string& topic, const std::string& payload)> callback) { on_message_callback_ = callback; }

protected:
    int keep_alive_seconds_ = 60;
    std::function<void(const std::string& topic, const std::string& payload)> on_message_callback_;
    std::function<void()> on_connected_callback_;
    std::function<void()> on_disconnected_callback_;
};

```

```c
mqtt_ = new EspMqtt();
mqtt_->SetKeepAlive(90);

mqtt_->OnDisconnected([this]() {
    ESP_LOGI(TAG, "Disconnected from endpoint");
});
// 处理服务器的消息回调函数
mqtt_->OnMessage([this](const std::string& topic, const std::string& payload) {
    ESP_LOGI(TAG, "Received message on topic %s: %s", topic.c_str(), payload.c_str());
    // 解析payload，假设它是一个 JSON 字符串
    cJSON* root = cJSON_Parse(payload.c_str());
    if (root == nullptr) {
        ESP_LOGE(TAG, "Failed to parse JSON payload: %s", payload.c_str());
        return;
    }

    // 获取设备类型
    cJSON* type = cJSON_GetObjectItem(root, "type");
    if (type == nullptr || !cJSON_IsNumber(type)) {
        ESP_LOGE(TAG, "Device type is not specified or invalid");
        cJSON_Delete(root);
        return;
    }
    int type_value = type->valueint;
    ESP_LOGI(TAG, "Device type value: %d", type_value);
    // 根据设备类型创建 Thing
    if(type_value == 1){
        Message_Deal_Phone(root, payload);
    }else if(type_value == 2){
        Message_Deal_Follow(root, payload);
    }else if(type_value == 3){
        // 释放消息发送事件
        ElectronicPet* pet = ElectronicPet::GetInstance();
        if (pet != nullptr && pet->message_send_event_ != nullptr) {
            xEventGroupSetBits(pet->message_send_event_, MESSAGE_SEND_EVENT);
        }
    }
    cJSON_Delete(root);
});

if (!mqtt_->Connect(CONFIG_PET_MQTT_SERVER, 1883, client_id_.c_str(), "", "")) {
    ESP_LOGE(TAG, "Failed to connect to endpoint");
    return ;
}
// 发布的地址 
publish_topic_ = TOPIC_MESSAGE;
// 测试的订阅 
std::string real_address_str(TOPIC_MESSAGE);
real_address_str += boardID;
// 开始订阅
mqtt_->Subscribe(real_address_str, 2);
```

## idf使用

### 配置文件

在使用idf的设置界面进行选择配配置的时候添加自定义的选项

[构建系统（CMake 版） - ESP32 - — ESP-IDF 编程指南 v4.2.1 文档](https://docs.espressif.com/projects/esp-idf/zh_CN/v4.2.1/esp32/api-guides/build-system.html#add-conditional-config)

```
menu "XvSenfeng Electronic Pet"
    config FREQUENCE_OF_PET
        int "宠物交互的频率,数字越大越频繁"
        default 5
    config PET_GAME_TEXT_LENG
        int "宠物游戏文本长度,数字越大越长"
        default 300

    config PET_MQTT_SERVER
        string "宠物MQTT服务器地址"
        default "mqtt.tenclass.net"
        help
            该服务器用于连接宠物设备的 MQTT 服务

    config SERVER_BASE_SERVER_URL
        string "宠物服务器地址"
        default "https://www.xvsenfeng.top"
        help
            该服务器用于连接宠物设备的 HTTP 服务
        
endmenu
```

这里面的配置可以在CMakeList.txt里面直接使用用于文件的配置, 也可以用于在代码里面使用条件编译

### 自定义库文件

idf一个比较好用的点是他提供了丰富的组件, 可以直接使用组件库进行添加[ESP Component Registry](https://components.espressif.com/)

这部分的配置放在idf_component.yml文件里面, 可以在这个文件里面直接添加组件, 也可以idf的终端里面直接使用![image-20250906112128343](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509061121407.png)这里获取到的命令

直接使用的时候会出现一个问题, 默认idf在编译的时候会检查重新下载库文件, 所以如果发现一个库文件的使用不符合预期, 需要进行自定义的时候, 你的修改会被覆盖

这时候可以先下载一个原版的库文件, 之后移出来使用path关键字指定你自己定制的库文件

![image-20250906112411910](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509061124978.png)

> 这里我修改了原版的表情图片, 为了避免自己被覆盖, 所以使用这个方法

