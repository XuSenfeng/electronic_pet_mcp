# 宠物状态系统

## 数据结构

### 宠物类

```c
class ElectronicPet {
private:
    std::mutex mutex_;
    state_t state_[E_PET_STATE_NUMBER];     // 当前状态
    int game_state_[E_PET_GAME_STATE_NUMBER]; // 游戏状态
    
    std::vector<BaseThing *> things_; // 物品列表
    std::vector<FocueInfo> focus_list_; // 关注列表
    electronic_pet_action_e action_; // 当前行动
    electronic_pet_action_e action_last_; // 上次行动

    int current_game = 0;
    int is_game_ = 0;
    int level_ = 0; // 等级
    int experience_ = 0; // 经验值
    

    PMQTT_Clinet *client_; // MQTT客户端
    bool use_web_server_ = false;
    std::string boardID;

public:
    EventGroupHandle_t message_send_event_ = nullptr;
    std::vector<GameInfo> games_;
    static int state_time_change_[E_PET_ACTION_NUMBER][E_PET_STATE_NUMBER]; // 不同状态下边宠物的状态变化
    static std::string action_name_[E_PET_ACTION_NUMBER]; // 不同状态下边宠物的状态变化
    ElectronicPetTimer *timer;
    static ElectronicPet* MyPet;
    ElectronicPet();
    ~ElectronicPet();

    PMQTT_Clinet *GetClient() { return client_; }


    int GetAction() const { return action_; } // 获取当前的行为
    void SetAction(int action); // 设置当前的行为
    int GetState(int state) const { return state_[state].value; } // 获取当前的某一个状态
    void SetState(int state, int value); // 设置当前的某一个状态
    void SetStateName(int state, const char* name) { strcpy(state_[state].name, name); } // 设置状态的名字
    char *GetStateName(int state) { return state_[state].name; } // 获取某个状态的名字
    char *GetActionName() { return (char *)action_name_[action_].c_str(); } // 获取当前行为的名字
    void ReadCsv();  // 从SD卡读取csv文件
    void ReadCsvFood(int *i); // 读取csv的食物
    void ReadCsvGames(); // 读取游戏的配置文件
    // 获取有几个物品
    int GetThingsNum() { 
        return things_.size();
    }
    // 获取某个物品
    BaseThing *GetThing(int i) { 
        if (i < 0 || i >= things_.size()) return nullptr;
        return things_[i]; 
    }
    // 获取当前的游戏索引
    int GetCurrentGame() { return current_game; }
    // 设置当前的游戏索引
    void SetCurrentGame(int game) { current_game = game; }
    // 返回之前的状态, 主要用于游戏返回的时候
    void ReturnLastAction();
    // 设置游戏状态(用于处理游戏时候的特殊判断
    inline int isGame() const { return is_game_; }
    inline void setGame(int game) { is_game_ = game; }
    // 设置游戏的马哥粗略的
    void setGameState(int state, int value) { game_state_[state] = value; }
    int getGameState(int state) const { return game_state_[state]; }
    // 处理一下状态变换以后的回复
    void StateEventDeal();
    // 经验以及升级
    int getLevel() { return level_; }
    int getExperience() { return experience_; }
    // 创建一个物品
    bool CreatOneThing(char *name, char *description, int vigor_, int satiety_, int happiness_, int money_, int iq_, int level, int *i);

    // 判断是不是可以升级(升级部分是不完善的)
    inline bool isUpGraded(){return experience_ >= level_ * level_;}
    std::string ReadUpgradeTaskCsv(int level);
    
    // 在其他文件用于获取宠物句柄
    static ElectronicPet* GetInstance();

    // 对当前的状态实现加减
    void change_statue(int *change_state);
    std::string GetUpdateTask(void);
    bool Upgrade(void);

    // 获取板子的ID用于和微信小程序配合
    std::string GetBoardID(void);
    // 读取各种消息
    void ReadWebThings(void);
    void ReadWebFood(int *thing_num);
    void ReadWebGames(void);
    void ReadWebFocus(void);
    std::string GetFocusListJson(void);
    std::vector<FocueInfo> GetFocusList(void){return focus_list_;};
    // 更新当前的状态
    void UploadState(void);
};
```



### 各项数值

+ 宠物的各项数值

```c
typedef enum{
    E_PET_STATE_VIGIR = 0, // 精力
    E_PET_STATE_SATITY, // 饱食度
    E_PET_STATE_HAPPINESS, // 快乐度
    // E_PET_STATE_GOOD_LINE 之前的数值用于判断状态好坏
    E_PET_STATE_IQ, // 智商
    // E_PET_DIVIDING_LINE 之前的数字有上限100
    E_PET_STATE_MONEY, // 金钱
    E_PET_STATE_NUMBER // 状态数量
}electronic_pet_state_e;
```

在处理这部分数据的时候, 前面的几项使用的是百分之, 所以是有上限的, 后面的数据是没有上限的, 住部分之后在显示的时候需要区分一下

同时使用三个数值综合判断宠物的当前是不是感觉比较好, 比较好的话可以增加经验值

```c
#define E_PET_STATE_DIVIDING_LINE 4 // 分割线
#define E_PET_STATE_GOOD_LINE 3 // 分割线
```

+ 宠物的各种状态

```c
typedef enum{
    E_PET_ACTION_IDLE = 0, // 空闲
    E_PET_ACTION_PLAY, // 玩耍
    E_PET_ACTION_SLEEP, // 睡觉
    E_PET_ACTION_WALK, // 散步
    E_PET_ACTION_BATH, // 洗澡
    E_PET_ACTION_WORK, // 工作
    E_PET_ACTION_STUDY, // 学习
    E_PET_ACTION_PLAY_MUSIC, // 听音乐
    E_PET_ACTION_NUMBER // 状态数量
}electronic_pet_action_e;
```

> 这部分的数据主要是对应于之后我想实现的功能, 处于不同状态的时候宠物的数据会以不同的形式进行更新

+ 打游戏的时候使用的几项数据

```c
typedef enum{
    E_PET_GAME_STATE_HP = 0, // 血量
    E_PET_GAME_STATE_SCORE, // 分数
    E_PET_GAME_STATE_ENERGY, // 能量
    E_PET_FAME_STATE_FAME, // 名声
    E_PET_GAME_STATE_NUMBER // 状态数量
}electronic_pet_game_state_e;
```

> 提升游戏沉浸感, 是AI可以直接控制的数据

## 数据的更新

### 状态的更新

由于不同的行为下面的宠物状态的更新是不同的, 所以这里需要记录一下不同的情况里面是如何更新的, 我使用的是一个数组

```c
static int state_time_change_[E_PET_ACTION_NUMBER][E_PET_STATE_NUMBER]; // 不同状态下边宠物的状态变化
```

```c
// 精力, 饱食度, 快乐度
int ElectronicPet::state_time_change_[E_PET_ACTION_NUMBER][E_PET_STATE_NUMBER] = {
    /* E_PET_ACTION_IDLE 空闲*/      {-1, -1, -1, 0, 0},
    /* E_PET_ACTION_PLAY 玩耍*/       {-3, -3, 5, 0, 0},
    /* E_PET_ACTION_SLEEP 睡觉*/      {2, -1, 0, 0, 0},
    /* E_PET_ACTION_WALK 走路*/       {-2, -2, 1, 0, 0},
    /* E_PET_ACTION_BATH 洗澡*/       {-1, -1, 1, 0, 0},
    /* E_PET_ACTION_WORK 工作*/       {-4, -2, -4, 0, 1},
    /* E_PET_ACTION_STUDY 学习*/      {-4, -2, -3, 1, 0},
    /* E_PET_ACTION_PLAY_MUSIC 听歌*/ {-1, -1, 2, 0, 0}
};
```

> 每一行对应一个行为状态, 每一列对应的是一个状态, 在单次更新的时候更新的数值的大小

这部分数据需要定期进行更变, 所以要初始化一个时钟, 这里使用的是时钟系统里面的时钟回调函数(时钟系统后面讲), 在里面会执行函数

```c
void ElectronicPetTimer::OnClockTimer() {    
	// 加锁避免互斥
    std::lock_guard<std::mutex> lock(mutex_);
    timer_event_process(); // 时钟事件的处理函数, 暂时不用管
    clock_ticks_++; // 更新事件
    // 获取一下宠物
    ElectronicPet* pet = ElectronicPet::GetInstance();
    if(pet == nullptr){
        return;
    }
    // 初级的处理部分
    if(clock_ticks_ % (1000 / CONFIG_FREQUENCE_OF_PET) == 0){
        ESP_LOGI(TAG, "Clock ticks: %d", clock_ticks_);
        // 更新一下状态
        int state[E_PET_STATE_NUMBER]; // 记录更新的数值大小
        for(int i = 0; i < E_PET_STATE_NUMBER; i++){
            state[i] = ElectronicPet::state_time_change_[pet->GetAction()][i];
        }
        state[E_PET_STATE_MONEY] *= (state[E_PET_STATE_IQ] / 20); // 智商越高，钱越多
        pet->change_statue(ElectronicPet::state_time_change_[pet->GetAction()]);
        

        if(clock_ticks_ % 1000 == 0){
            pet->UploadState(); // 同步到服务器
        }

        if(pet->isGame() == false){
            pet->StateEventDeal(); // 状态在一定阈值的时候需要主动发起聊天
        }
    }
}
```









