# 时钟系统

时钟可以说是整个系统里面最重要的一个部分, 不只是宠物的交互需要使用, 在使用物联网控制的时候也需要大量使用, 同时也是生活中的一个十分实用的小功能, 我之前出过一个版本的小智闹钟,, 但是实际定时的时候使用相对时间, 导致时间的精度不高, 所以此次进行全部升级

1. 主动发起交互
2. 处理一些嵌入式的事件

在实际处理的时候需要记住以下的几个思路

+ 添加的时候计算实际第一次触发的事件time_t
+ 所有时间进行排序, 定期处理所有比当前事件小的触发的事件
+ 处理的时候根据时钟的类型分为消息通知以及工具调用两种
+ 如果触发的事件是循环的, 再次记录下一次的触发时间, 循环的时间可自定义循环的周期(可随机)

## 数据结构

```c
// 定时器事件类型
typedef enum {
    E_PET_TIMER_MESSAGE = 0, // 消息
    E_PET_TIMER_FUNCTION, // 函数
}e_pet_timer_type_e;


// 定时器事件回调函数
typedef struct {  
    void (*callback)(void*);  
    void* arg;
}e_pet_timer_function;

// 定时器事件
typedef struct{
    time_t trigger_time; // 触发时间
    e_pet_timer_type_e type; // 事件类型
    int repeat_time; // 重复时间
    int random_l; // 随机时间
    int random_h; // 随机时间
    union {
        e_pet_timer_function function;
        char *message;
    };
}e_pet_timer_event_t;


// 定时器类
class ElectronicPetTimer {
private:
    int clock_ticks_;  // 时钟
    std::mutex mutex_; // 互斥锁
    esp_timer_handle_t electromic_prt_timer_ = nullptr; // 定时器句柄
    std::vector<e_pet_timer_event_t> e_pet_timer_events; // 处理事件列表
    bool from_web_ = false; // 是否从web读取
    std::string boardID; // 板子ID
public:
    ElectronicPetTimer(bool from_web = false, const char* boardID = "");
    ~ElectronicPetTimer();
    
    void OnClockTimer(); // 时钟定时器
    void TimerEventSort(); // 定时器事件排序
    
    void TimerAddTimerEventRelative(int seconds, e_pet_timer_type_e type, void (*callback)(void*), void* arg, bool repeat);
    void TimerAddTimerEventAbsolute(time_t trigger_time, e_pet_timer_type_e type, void (*callback)(void*), void* arg, bool repeat); // 添加定时器事件绝对时间
    void TimerAddTimerEventRepeat(time_t trigger_time, e_pet_timer_type_e type, void (*callback)(void*), void* arg, int repeat_time, int random_l, int random_h); // 添加定时器事件重复时间(实际使用的)

    void TimerEventProcess();  // 定时器事件处理

    void TimerReadWebTimer(); // 读取web定时器
    void TimerReadCsvTimer(); // 读取csv定时器
    bool DealTimerInfo(timer_info_t *timer_info); // 添加一个定时器事件
    
    void CalculationNextAndRepeat(timer_info_t *csv_info, long *delta_sec, long *interval_sec); // 计算下一个触发时间以及重复时间
};
```

## 添加时钟

鉴于之前只使用一个相对时间的处理情实际AI的处理结果并不让人满意, 所以我这里使用了相对时间+绝对时间相结合的处理方式, 目前实际使用的是绝对时间+循环的模式

+ 只触发一次

可以直接依次填写触发的时间即可

+ 循环触发

循环触发的时候可以设置是不是固定的循环, 对应的循环周期使用负数, 比如3周循环, 就把周对应的字段设置为-3

也可以加一个随机的设置, 设置random_l和random_h变量即可控制循环的随机分量上下限

### 时间的计算函数

时钟的处理分为两部分, 第一部分是计算下一个触发的时候, 第二个

```c
// 计算最大公约数
long gcd(long a, long b) {
    return b == 0 ? a : gcd(b, a % b);
}

// 计算最小公倍数
long lcm(long a, long b) {
    return (a * b) / gcd(a, b);
}

// 辅助函数：判断闰年
int is_leap_year(int year) {
    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
}

// 辅助函数：获取指定月份的天数
int get_month_days(int year, int month) {
    static const int days[] = {31,28,31,30,31,30,31,31,30,31,30,31};
    if (month == 1 && is_leap_year(year)) 
        return 29;
    return days[month];
}

// 计算下一个触发时间以及重复时间
void calculate_next_trigger(
    int tm_sec, int tm_min, int tm_hour,
    int re_mday, int re_mon, int re_year,
    int re_wday, long* delta_sec, long* interval_sec) {
    
    time_t now;
    time(&now);
    struct tm* current = localtime(&now); // 当前时间

    struct tm next = *current; // 下一个时间

    // 初始化周期参数
    long interval = 1; // 周期时间
    int has_periodic = 0; // 是否周期

    // 处理时间字段
    #define PROCESS_FIELD(field_suffix, var, max, unit_sec) \
        if (!has_periodic &&  var < 0) { \
            interval = lcm(interval, labs(var) * (unit_sec)); \
            has_periodic = 1; \
        } else if (!has_periodic && var >= 0 && var <= max) { \
            next.tm_##field_suffix = var; \
        }

    // 修正调用方式：明确分离结构体字段后缀和变量名
    PROCESS_FIELD(sec, tm_sec, 59, 1)
    PROCESS_FIELD(min, tm_min, 59, 60)
    PROCESS_FIELD(hour, tm_hour, 23, 3600)

    if (re_wday != 0) { // 0表示不设置星期条件
        // 转换输入范围：0-7 → 0-6（周日=0）
        int target_wday = (re_wday < 0) ? labs(re_wday) % 7 : re_wday % 7;
        
        // 处理周期性（负数表示周期）
        if (re_wday < 0) {
            // 计算周周期（绝对值×7天的秒数）
            long week_interval = 604800L; 
            interval = lcm(interval, week_interval);
            has_periodic = 1;
            
            // 设置初始触发日为下一个目标星期几
            int days_to_add = (target_wday - next.tm_wday + 7) % 7;
            days_to_add = (days_to_add == 0) ? 7 : days_to_add; // 确保至少增加1天
            next.tm_mday += days_to_add;
        } 
        // 处理单次指定（正数）
        else if (re_wday > 0) {
            // 计算需要增加的天数（考虑跨周情况）
            int days_diff = (target_wday - next.tm_wday + 7) % 7;
            // 如果当天已过目标星期几，则跳到下周
            if (days_diff == 0 && mktime(&next) <= now) {
                days_diff = 7;
            }
            next.tm_mday += days_diff;
        }
        
    }

    // 处理日期字段
    if (!has_periodic &&  re_mday < 0) {
        interval = lcm(interval, labs(re_mday) * 86400L);
        has_periodic = 1;
    } else if (!has_periodic &&  re_mday > 0) {
        next.tm_mday = re_mday;
    }

    if (!has_periodic &&  re_mon < 0) { // 月周期处理
        if(mktime(&next) < now) {
            next.tm_mon += labs(re_mon);
        }

        int year = next.tm_year + 1900 + next.tm_mon / 12;
        int month = next.tm_mon % 12;

        interval = lcm(interval, labs(re_mon) * get_month_days(year, month) *86400L); // 近似值
        // 调整日期到有效值

        int max_day = get_month_days(year, month);
        if (next.tm_mday > max_day)
            next.tm_mday = max_day;
        has_periodic = 1;
    } else if (!has_periodic &&  re_mon > 0) {
        next.tm_mon = re_mon - 1;
    }

    if (!has_periodic &&  re_year < 0) { // 年周期处理
        int year = next.tm_year + 1900;
        interval = lcm(interval, labs(re_year) * (is_leap_year(year) ? 366 : 365) * 86400L);
        if(mktime(&next) < now) {
            next.tm_year += labs(re_year);
        }
        // 闰年调整
        if (next.tm_mon == 1) { // 二月
            int max_day = is_leap_year(year) ? 29 : 28;
            if (next.tm_mday > max_day)
                next.tm_mday = max_day;
        }
        has_periodic = 1;
    } else if (!has_periodic &&  re_year > 0) {
        next.tm_year = re_year - 1900;
    }

    // 计算初始候选时间
    next.tm_isdst = -1;
    time_t candidate = mktime(&next);
    // 自动调整策略
    while (1) {
        // 处理时间已过的情况
        if (candidate <= now) {
            // printf("Candidate time has passed, adjusting...\n");
            if (has_periodic) {
                candidate += interval;
            } else {
                // 单次事件已过期
                *delta_sec = -1;
                *interval_sec = 0;
                return;
            }
            continue;
        }
        break;
    }

    *delta_sec = candidate - now;
    *interval_sec = has_periodic ? interval : 0;
}
```

## 回调函数

在定时的时候, 不只是可以使用对话作为出发条件, 也可以使用一个回调函数实现实际的功能, 只需要在注册时候选择对应的类型即可

```c
typedef void (*callback_f)(void*);
typedef struct{
    callback_f callback;
    void *arg;
}callback_t;

// 回调函数的列表
callback_t callback_catalogue[20] = {
    {test_callback, (void *)"test1"},
};
```



