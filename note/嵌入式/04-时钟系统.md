# 时钟系统

时钟可以说是整个系统里面最重要的一个部分, 不只是宠物的交互需要使用, 在使用物联网控制的时候也需要大量使用, 同时也是生活中的一个十分实用的小功能, 我之前出过一个版本的小智闹钟,, 但是实际定时的时候使用相对时间, 导致时间的精度不高, 所以此次进行全部升级

在实际处理的时候需要记住以下的几个思路

+ 添加的时候计算实际第一次触发的事件time_t
+ 所有时间进行排序, 定期处理所有比当前事件小的触发的事件
+ 处理的时候根据时钟的类型分为消息通知以及工具调用两种
+ 如果触发的事件是循环的, 再次记录下一次的触发时间, 循环的时间可自定义循环的周期(可随机)

## 数据结构

```c
// 定时器事件类型
typedef enum {
    E_PET_TIMER_MESSAGE = 0, // 消息
    E_PET_TIMER_FUNCTION, // 函数
}e_pet_timer_type_e;


// 定时器事件回调函数
typedef struct {  
    void (*callback)(void*);  
    void* arg;  
}e_pet_timer_function;

// 定时器事件
typedef struct{
    time_t trigger_time; // 触发时间
    e_pet_timer_type_e type; // 事件类型
    int repeat_time; // 重复时间
    union {
        e_pet_timer_function function;
        char *message;
    };
}e_pet_timer_event_t;


// 定时器类
class ElectronicPetTimer {
private:
    int clock_ticks_;  // 时钟
    std::mutex mutex_; // 互斥锁
    esp_timer_handle_t electromic_prt_timer_ = nullptr; // 定时器句柄
    std::vector<e_pet_timer_event_t> e_pet_timer_events; // 处理事件列表
    bool from_web_ = false; // 是否从web读取
    std::string boardID; // 板子ID
public:
    ElectronicPetTimer(bool from_web = false, const char* boardID = "");
    ~ElectronicPetTimer();
    
    void OnClockTimer(); // 时钟定时器
    void TimerEventSort(); // 定时器事件排序
    
    void TimerAddTimerEventRelative(int seconds, e_pet_timer_type_e type, void (*callback)(void*), void* arg, bool repeat);
    void TimerAddTimerEventAbsolute(time_t trigger_time, e_pet_timer_type_e type, void (*callback)(void*), void* arg, bool repeat); // 添加定时器事件绝对时间
    void TimerAddTimerEventRepeat(time_t trigger_time, e_pet_timer_type_e type, void (*callback)(void*), void* arg, int repeat_time, int random_l, int random_h); // 添加定时器事件重复时间(实际使用的)

    void TimerEventProcess();  // 定时器事件处理

    void TimerReadWebTimer(); // 读取web定时器
    void TimerReadCsvTimer(); // 读取csv定时器
    bool DealTimerInfo(timer_info_t *timer_info); // 添加一个定时器事件
    void CalculationNextAndRepeat(timer_info_t *csv_info, long *delta_sec, long *interval_sec); // 计算下一个触发时间以及重复时间
};
```

## 添加时钟

鉴于之前只使用一个相对时间的处理情实际AI的处理结果并不让人满意, 所以我这里使用了相对时间+绝对时间相结合的处理方式, 目前实际使用的是绝对时间+循环的模式

